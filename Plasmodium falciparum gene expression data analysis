rm(list = ls())
library(deSolve)
library(Matrix)
library(deSolve)
library(orthopolynom)
library(ggplot2)
library(ADSIHT)
library(reshape2)
library(patchwork)
library(splines)
library(dplyr)
library(ggh4x)
library(purrr)

expdata = read.csv(file = "D6.csv", header = T)
rownames(expdata) = expdata[,1]
expdata = expdata[,-1]
check_df <- function(data){
  if ( length(which(data==0))>= ncol(expdata)*0.3 ) {
    data[which(data==0)] <- NA
    return(data)
  }
  else
    return(data)
}
expdata <- data.frame(na.omit(t(apply(expdata, 1, check_df))))
times <- as.numeric(gsub("X", "", colnames(expdata)))
psi <- function(x) {
  c(sin(x),cos(x),sin(2*x),cos(2*x),sin(3*x),cos(3*x))
}
n_order=length(psi(times[1]))
#load clustering result
load("result_k16.RData")

fourier <- function(par,times,order){
  #value
  acq.freq <- 1                 
  time <- length(times)       
  ts <- seq(1,time,1/acq.freq)    
  f.0 <- 1/time                   
  w <- 2*pi*f.0
  #par
  a0 <- par[1]
  par.cos <- par[2:(1+order)]
  par.sin <- par[(2+length(par.cos)):(1+2*length(par.cos))]
  theta <- par[length(par)]
  #
  p <- 1:order
  y <- a0 + rowSums(sapply(1:order, function(c) par.cos[c]*cos(theta*w*ts*p[c]))) + 
    rowSums(sapply(1:order, function(c) par.sin[c]*sin(theta*w*ts*p[c]))) 
  return(y)
}

curve_par <- result$curve_par
m_curve <- apply(curve_par, 1, function(par) {
  fourier(par, times, order=1)
})

ODEsolve <- function(data,times,n_order,basic){
  orig_times = times
  # if(is.null(times)){
  #   times = 1:nrow(data)
  #   orig_times = times
  # }
  
  # p = ncol(data)
  
  #smooth data
  fit <- lapply(1:ncol(data), function (xi) 
    smooth.spline(times, as.numeric(data[,xi])))
  
  x_smooth <- sapply(1:ncol(data), function(xi)  predict(fit[[xi]], x = times)$y)
  colnames(x_smooth) <- colnames(data)
  rownames(x_smooth) <- rownames(data)

  
  #plot
  select = c(1:p)
  plt_df1 = melt(data[,select])
  plt_df2 = melt(x_smooth[,select])
  
  
  ggplot()+geom_point(plt_df1, mapping = aes(x = Var1, y = value,group = Var2),size = 0.1)+
    geom_line(plt_df2, mapping = aes(x = Var1, y = value,group = Var2),linewidth = 0.1)+
    facet_wrap(~Var2, scales = "free_y")
  
  group <- rep(1:(p*p), each=n_order+1)
  ind_Leg0 <- c(0:(p-1))*(p*(n_order+1))+1 + rep(0:(p-1)) * (n_order+1)
  Leg0 <- seq(1,length(group), by = n_order+1)
  dep_Leg0 <- setdiff(Leg0, ind_Leg0)
  group <- group[-dep_Leg0]
  
  # Legendre basis
  if (basic=="LOP"){
    get_LOP_M <- function(x, n_order,times, name = NULL) {
      # Generate Legendre basis (excluding the constant term)
      x <- as.numeric(x)
      LOP <- legendre.polynomials(n = n_order)
      #leg <- polynomial.values(polynomials=LOP,x = scaleX(x, u = -1, v = 1))
      leg <- polynomial.values(polynomials=LOP,x = x)
      #integral over times
      fs = lapply(leg,splinefun,x = times)
      mod <- function (Time, State, Pars, basis) {
        with(as.list(c(State, Pars)), {
          dy = basis(Time)
          return(list(dy))
        })
      }
      Pars <- NULL
      State <- rep(0,length(leg))
      
      leg <- sapply(1:length(fs),function(xi)
        ode(func = mod, y = State[[xi]], parms = Pars,
            basis = fs[[xi]], times = times)[,2])
      
      if (is.null(name)) {
        colnames(leg) <- paste0("leg", 0:(ncol(leg)-1))
      } else {
        colnames(leg) <- paste0(name, "__leg", 0:(ncol(leg)-1))
      }
      leg
    }
    x_basis <- Reduce(cbind, lapply(1:p, function(xi) {
      get_LOP_M(x = x_smooth[, xi], n_order,times)
    }))
  } else{
    # 三角基
    get_basic <- function(x, n_order,times, name = NULL) {
      # Generate basis
      x <- as.numeric(x)
      P <- split(psi(x), rep(1:n_order, each = length(x)))
      #integral over times
      fs = lapply(P,splinefun,x = times)
      mod <- function (Time, State, Pars, basis) {
        with(as.list(c(State, Pars)), {
          dy = basis(Time)
          return(list(dy))
        })
      }
      Pars <- NULL
      State <- rep(0,length(P))
      P_integral <- sapply(1:length(fs),function(xi)
        ode(func = mod, y = State[[xi]], parms = Pars,
            basis = fs[[xi]], times = times)[,2])
      if (is.null(name)) {
        colnames(P_integral) <- paste0("basic", 1:(ncol(P_integral)))
      } else {
        colnames(P_integral) <- paste0(name, "__basic", 0:(ncol(P_integral)))
      }
      P_integral <- cbind(times, P_integral)
      colnames(P_integral)[1] <- "leg0"
      P_integral
    }
    x_basis <- Reduce(cbind, lapply(1:p, function(xi) {
      get_basic(x = x_smooth[, xi], n_order,times)
    }))
  }
  
  x_scaled <- scale(x_basis)
  X <- as.matrix(bdiag(rep(list(x_scaled), p)))
  X <- X[, -dep_Leg0]
  y_scaled <- scale(data)
  Y <- matrix(as.vector(y_scaled), ncol = 1)
  order0_positions <- sapply(as.numeric(names(table(group)[table(group) == max(table(group))])), 
                             function(num) which(group == num)[1])
  ## 双稀疏
  #res_ds <- ADSIHT(x = X, y = Y, group = group,L=n_order)
  res_ds <- ADSIHT(x = X, y = Y, group = group, L = n_order,kappa = 0.99, ic.scale = 10, ic.coef = 10)
  
  beta_ds <- res_ds$beta[,which.min(res_ds[["ic"]])]
  beta_ds <- matrix(beta_ds, nrow = p * n_order + 1, ncol = p)
  beta0_scaled_ds <- res_ds$intercept[which.min(res_ds[["ic"]])]
  lambda = res_ds$lambda[which.min(res_ds[["ic"]])]
  # 没有独立效应的方程
  ind_0 <- which(sapply(1:p, function(i) {
    all(beta_ds[-1,][c(n_order*(i - 1)+1, n_order*i), i] == 0)
  }))
  for (equ in ind_0) {
    m <- nrow(x_scaled)
    q <- p*n_order+1
    X_sub <- X[( (equ-1)*m + 1 ) : (equ*m), ( (equ-1)*q + 1 ) : (equ*q)]
    Y_sub <- Y[( (equ-1)*m + 1 ) : (equ*m), ]
    X_sub <- X_sub[, c(((equ-1)*n_order+2):(equ*n_order+1),which(beta_ds[, equ]!=0))]
    # 预估计
    res_sub <- lm(Y_sub ~ X_sub)
    # 加惩罚的最小二乘
    ols_loss <- function(beta) {
      sum((Y_sub - (X_sub %*% beta+beta0_scaled_ds))^2)}
    init_beta <- res_sub$coefficients[-1]
    init_beta[is.na(init_beta)] <- rep(0, length(init_beta[is.na(init_beta)]))
    ols_result <- optim(par = init_beta, fn = ols_loss, method = "BFGS")
    # 更新参数
    beta_ds[c(((equ-1)*n_order+2):(equ*n_order+1),which(beta_ds[, equ]!=0)), equ] <-
      ols_result$par
    }
  ind_1 = setdiff(1:p, ind_0)
  for (equ in ind_1) {
    m <- nrow(x_scaled)
    q <- p*n_order+1
    X_sub <- X[( (equ-1)*m + 1 ) : (equ*m), ( (equ-1)*q + 1 ) : (equ*q)]
    Y_sub <- Y[( (equ-1)*m + 1 ) : (equ*m), ]
    X_sub <- X_sub[, c(which(beta_ds[, equ]!=0))]
    # 预估计
    res_sub <- lm(Y_sub ~ X_sub)
    res_sub$coefficients[is.na(res_sub$coefficients)] <- rep(0, length(res_sub$coefficients[is.na(res_sub$coefficients)]))
    # 加惩罚的最小二乘
    ols_loss <- function(beta) {
      alpha=5e-3
      sum((Y_sub - (X_sub %*% beta+beta0_scaled_ds))^2+alpha*(sum(beta^2)))}
    init_beta <- res_sub$coefficients[-1]
    ols_result <- optim(par = init_beta, fn = ols_loss, method = "BFGS")
    # 更新参数
    beta_ds[c(which(beta_ds[, equ]!=0)), equ] <-
      ols_result$par
  }
  beta_ds[abs(beta_ds) < lambda]= 0
  
  # turn beta
  get_B_est <- function(beta,beta0_scaled) {
    beta_est <- matrix(beta[-order0_positions], nrow = p * n_order, ncol = p)
    beta_est <- rbind(beta[order0_positions],beta_est)

    sY <- attr(y_scaled, "scaled:scale")
    mY <- attr(y_scaled, "scaled:center")
    sX <- attr(x_scaled, "scaled:scale")
    sX <- c(sX[1],sX[!grepl("leg0", names(sX))])
    mX <- attr(x_scaled, "scaled:center")
    mX <- c(mX[1],mX[!grepl("leg0", names(mX))])

    BETA <- lapply(1:p, function(xi) {
      beta_orig <- beta_est[, xi] * (sY[xi] / sX)
      return(beta_orig)
    })
    BETA0 <- lapply(1:p, function(xi) {
      orig_int <- beta0_scaled * sY[xi] + mY[xi] - sum(BETA[[xi]] * mX)
      return(orig_int)
    })
    B_est = t(cbind(unlist(BETA0),t(Reduce(cbind,BETA))))
    B_est
  }
  B_est_ds <- get_B_est(beta=beta_ds, beta0_scaled = beta0_scaled_ds)
  x_basis_est <- cbind(1, x_basis[,1], x_basis[,!grepl("leg0", colnames(x_basis))])
  
  #不标准化
  # x_basis_est <- cbind(1, x_scaled[,1], x_scaled[,!grepl("leg0", colnames(x_scaled))])
  # 
  # B_est_ds <- matrix(beta_ds[-order0_positions], nrow = p * n_order, ncol = p)
  # B_est_ds <- rbind(beta_ds[order0_positions],B_est_ds)
  # B_est_ds <- rbind(beta0_scaled_ds, B_est_ds)
  
  plot_est <- function(){
    tmp = x_basis_est%*%B_est_ds
    colnames(tmp) = paste0("M",1:p)
    rownames(tmp) = orig_times
    tmp = melt(tmp)
    
    rownames(data) = orig_times
    tmp2 = melt(data)
    
    
    p = ggplot()+geom_line(data = tmp, mapping = aes(x = Var1, y = value, color=Var2))+
      geom_point(data = tmp2, mapping = aes(x = Var1, y = value, color=Var2),alpha=0.3)+
      facet_wrap(~Var2, scales = "free_y")
    p
  }
  plot_est()
  
  residual = data - x_basis_est%*%B_est_ds
  residual = sum(residual^2)
  
  return(list(x_basis = x_basis_est,
              BETA_est = B_est_ds,
              x_smooth = x_smooth,
              obs= data,
              residual =  residual,
              x_fit = fit)) 
}

res <-  ODEsolve(data = m_curve,n_order=n_order, times = times,basic = "L1OP")

B_est_ds = res$BETA_est
x_basis_est = res$x_basis
obs = res$obs
x_smooth = res$x_smooth

idx = seq(3,(p*n_order+2))
idx_list = rep(list(split(idx, cut(seq_along(idx), breaks = p, labels = FALSE))), times = p)
idx_list <- lapply(seq_along(idx_list), function(i) {
  idx_list[[i]][[i]] = c(1,2,idx_list[[i]][[i]])
  return(idx_list[[i]])
})
trans_out <- function(out,j){
  id = paste0("M",j)
  
  out = as.data.frame(out)
  colnames(out) = c('time',"est",paste0("M",1:p))
  out <- out[, colSums(out) != 0, drop = FALSE]
  out = melt(out,id.vars = 'time')
  out$group = 'Dep'
  out$group[out$variable == id] = 'Ind'
  out$group[out$variable == 'est'] = 'est'
  out
}
get_effect_plot <- function(B_est, x_basis_est, times){
  trans_effect_est_list <- lapply(1:p, function(j) {
    effect_est <- cbind(times, rowSums(sapply(1:p, function(xi) x_basis_est[,idx_list[[j]][[xi]]] %*% B_est[idx_list[[j]][[xi]], j])),
                        sapply(1:p, function(xi) x_basis_est[,idx_list[[j]][[xi]]] %*% B_est[idx_list[[j]][[xi]], j]))
    trans_out(effect_est, j)
  })
  effect_est_all <- do.call(rbind, lapply(seq_along(trans_effect_est_list), function(i) {
    df <- trans_effect_est_list[[i]]
    df$equations <- paste0("M", i)
    return(df)
  }))
  effect_est_all$equations <- factor(effect_est_all$equations, levels = paste0("M", 1:p))
  ori <- as.data.frame(cbind(times,obs))
  ori <- melt(ori,id.vars = 'times')
  ori$equations <- rep(paste0("M", 1:p), each = length(times))
  ori$equations <- factor(ori$equations, levels = paste0("M", 1:p))
  plot_fun <- function(main_data,
                       ori_data = NULL,
                       bg_regions = list(
                         list(xmin = -Inf, xmax = 18, fill = "red", alpha = 0.2),
                         list(xmin = 36, xmax = 54, fill = "red", alpha = 0.2),
                         list(xmin = 18, xmax = 22, fill = "blue", alpha = 0.2),
                         list(xmin = 54, xmax = 58, fill = "blue", alpha = 0.2),
                         list(xmin = 22, xmax = 36, fill = "green", alpha = 0.2),
                         list(xmin = 58, xmax = Inf, fill = "green", alpha = 0.2)
                       ),
                       line_colors = c(est = 'blue', Ind = 'red', Dep = 'green'),
                       show_ori_points = !is.null(ori_data),
                       s_text,  # 添加阶段选项
                       add_bg,  # 添加背景色选项，默认为TRUE
                       add_hline) {  # 添加参考线选项，默认为TRUE
    
    # 创建基础绘图对象
    p <- ggplot()
    
    # 1. 添加背景区域
    if (add_bg) {
      for (region in bg_regions) {
        p <- p + annotate("rect",
                          xmin = region$xmin,
                          xmax = region$xmax,
                          ymin = -Inf,
                          ymax = Inf,
                          fill = region$fill,
                          alpha = region$alpha)
      }
    }
    
    # 2. 添加主数据线条
    p <- p +
      geom_line(main_data,
                mapping = aes(x = time, y = value, group = variable, color = group),
                linewidth = 1)
    
    # 3. 可选添加原始数据点
    if (show_ori_points && !is.null(ori_data)) {
      p <- p +
        geom_point(ori_data, mapping = aes(x = times, y = value),
                   color = 'blue', size = 0.3)
    }
    
    # 4. 添加文本标签
    if (s_text) {
      s_text <- data.frame(
        x1 = c(9, 20, 29),
        x2 = c(9, 20, 29) + 36,
        label = c("S1", "S2", "S3")
      )
      
      # 为每个equation计算最大值（确保包含equations列）
      max_values <- main_data %>%
        group_by(equations) %>%
        summarise(max_y = max(value))
      
      # 创建包含所有标签位置的数据框
      label_data <- max_values %>% 
        # 与s_text创建所有组合（每个子图×每个标签位置）
        tidyr::crossing(s_text) %>%  
        # 将x1和x2转换为长格式（每个标签位置占一行）
        tidyr::pivot_longer(
          cols = c(x1, x2),
          names_to = "pos_type",
          values_to = "x_pos"
        ) %>%
        # 调整y位置为最大值的90%（避免贴顶）
        mutate(y_pos = max_y)
      
      # 一次性添加所有标签
      p <- p +
        geom_text(
          data = label_data,
          aes(x = x_pos, y = y_pos, label = label),
          hjust = 0.5, vjust = -0.5, 
          size = 2.5, color = "black",
          inherit.aes = FALSE
        )
    }
    p <- p +
      geom_text(
        data = main_data %>% 
          filter(group == "Dep") %>% 
          group_by(variable) %>% 
          slice_max(time),
        mapping = aes(x = time, y = value, label = variable),
        hjust = 0.5, vjust = -0.5, size = 2.5, color = "black"
      )
    
    # 5. 选加参考线
    p <- p + geom_hline(yintercept = 0, color = "black", linewidth = 0.5)
    if (add_hline) {
      for (region in bg_regions[-length(bg_regions)]) {
        p <- p + geom_vline(xintercept = region$xmax, linetype = "dashed", 
                            color = "gray50", alpha = 0.5)
      }
    }
    
    # 6. 添加样式设置
    p <- p +
      scale_color_manual(values = line_colors) +
      theme_minimal() +
      facet_wrap(~equations, scales = "free_y") +
      labs(x = "Times", y = "Effect Value", color = "") +
      theme(
        panel.background = element_rect(fill = "white", color = "black"),
        strip.background = element_rect(fill = "white", color = NA),
        strip.text = element_text(color = "black", size = 10),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        # 添加刻度线设置
        axis.ticks = element_line(color = "black"),  # 设置刻度线颜色
        axis.ticks.length = unit(-0.15, "cm"),       # 设置刻度线长度
        axis.text = element_text(color = "black")   # 确保刻度标签可见
      )
    n_plots <- length(unique(main_data$equations))
    
    # 对所有子图应用相同的 y 轴扩展
    p <- p + facetted_pos_scales(
      y = rep(
        list(scale_y_continuous(expand = expansion(mult = c(0.05, 0.1)))), 
        n_plots
      )
    )
    
    return(p)
  }
  
  # 使用示例
  p1 <- plot_fun(main_data = effect_est_all,ori_data = ori, add_bg = F, add_hline = TRUE,
                 s_text = TRUE)  # 添加阶段文本标签
  p1
 
  trans_d_effect_est_list <- lapply(1:p, function(j) {
    effect_est <- cbind(times, rowSums(sapply(1:p, function(xi) x_basis_est[,idx_list[[j]][[xi]]] %*% B_est[idx_list[[j]][[xi]], j])),
                        sapply(1:p, function(xi) x_basis_est[,idx_list[[j]][[xi]]] %*% B_est[idx_list[[j]][[xi]], j]))
    fit <- lapply(1:(p+1), function (xi) smooth.spline(effect_est[,1], as.numeric(effect_est[,-1][,xi])))
    x_deriv <- sapply(1:(p+1), function(xi) predict(fit[[xi]], x = effect_est[,1], deriv = 1)$y)
    x_deriv <- cbind(effect_est[,1],x_deriv)
    trans_out(x_deriv, j)
  })
  d_effect_est_all <- do.call(rbind, lapply(seq_along(trans_d_effect_est_list), function(i) {
    df <- trans_d_effect_est_list[[i]]
    df$equations <- paste0("M", i)
    return(df)
  }))
  d_effect_est_all$equations <- factor(d_effect_est_all$equations, levels = paste0("M", 1:p))
  p2 <- plot_fun(
    main_data = d_effect_est_all,
    show_ori_points = FALSE , add_bg = F, add_hline = TRUE,
    s_text = TRUE
  )
  p2

  
  trans_d_effect_est_list <- lapply(1:p, function(j) {
    effect_est <- cbind(times, rowSums(sapply(1:p, function(xi) x_basis_est[,idx_list[[j]][[xi]]] %*% B_est[idx_list[[j]][[xi]], j])),
                        sapply(1:p, function(xi) x_basis_est[,idx_list[[j]][[xi]]] %*% B_est[idx_list[[j]][[xi]], j]))
    fit <- lapply(1:(p+1), function (xi) smooth.spline(effect_est[,1], as.numeric(effect_est[,-1][,xi])))
    x_deriv <- sapply(1:(p+1), function(xi) predict(fit[[xi]], x = effect_est[,1], deriv = 1)$y)
    x_deriv <- cbind(effect_est[,1],x_deriv)
    # 计算f(0)
    dep <- which(colSums(x_deriv[,c(-1,-2)]) != 0)[which(which(colSums(x_deriv[,c(-1,-2)]) != 0)!=j)]
    for (di in dep) {
      x <- x_smooth[, di]
      f <- x_deriv[,c(-1,-2)][, di]
      fit_spline <- smooth.spline(x, f, spar = 0.5)
      predict(fit_spline, 0)$y
      x_deriv[,c(-1,-2)][, di] <- x_deriv[,c(-1,-2)][, di] - predict(fit_spline, 0)$y
    }
    if (length(dep)==1){
      x_deriv[, -c(1, 2)][, j] <- x_deriv[, 2] - x_deriv[, -c(1, 2)][,dep]
    } else{
      x_deriv[, -c(1, 2)][, j] <- x_deriv[, 2] - rowSums(x_deriv[, -c(1, 2)][,dep])
    }
    
    # 最小值近似f(0)
    # min_position <- apply(x_smooth[,which(colSums(x_deriv[,c(-1,-2)]) != 0)], 2, which.min)
    # 
    # # 1. 预先计算非零列索引
    # non_zero_cols <- which(colSums(x_deriv[, -c(1, 2)], na.rm = TRUE) != 0)
    # 
    # # 2. 提取x_deriv对应列
    # x_deriv_subset <- x_deriv[, -c(1, 2)][, non_zero_cols]
    # 
    # # 3. 提取最小值位置的x_deriv值
    # f0 <- sapply(seq_along(non_zero_cols), function(i) {
    #   x_deriv_subset[min_position[i], i]
    # })
    # 
    # # 4. 从x_deriv_subset中减去f0
    # x_deriv_adjusted <- x_deriv_subset
    # for (i in seq_along(non_zero_cols)) {
    #   x_deriv_adjusted[, i] <- x_deriv_subset[, i] - f0[i]
    # }
    # x_deriv[, -c(1, 2)][, non_zero_cols] <- x_deriv_adjusted
    # if (ncol(x_deriv[, -c(1, 2)][,non_zero_cols])==2){
    #   x_deriv[, -c(1, 2)][, j] <- x_deriv[, 2] - x_deriv[, -c(1, 2)][,non_zero_cols[non_zero_cols != j]]
    # } else{
    #   x_deriv[, -c(1, 2)][, j] <- x_deriv[, 2] - rowSums(x_deriv[, -c(1, 2)][,non_zero_cols[non_zero_cols != j]])
    # }
    trans_out(x_deriv, j)
  })
  d_effect_est_all <- do.call(rbind, lapply(seq_along(trans_d_effect_est_list), function(i) {
    df <- trans_d_effect_est_list[[i]]
    df$equations <- paste0("M", i)
    return(df)
  }))
  d_effect_est_all$equations <- factor(d_effect_est_all$equations, levels = paste0("M", 1:p))
  p3 <- plot_fun(
    main_data = d_effect_est_all,
    show_ori_points = FALSE, add_bg = F, add_hline = TRUE,
    s_text = TRUE  
  )
  p3
  return(list(p1=p1,p2=p2,p3=p3))
}
effect_plot <- get_effect_plot(B_est=B_est_ds, x_basis_est=x_basis_est, times = times)
effect_plot
